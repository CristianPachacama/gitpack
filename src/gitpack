#!/bin/sh

#-------------------------------------------------------------------------------
# Copyright 2019 Dominik Salvet
# github.com/dominiksalvet/gitpack
#-------------------------------------------------------------------------------
# DESCRIPTION:
#   This is the main file of GitPack - Git-based package manager.
# PARAMETERS:
#   All given arguments are processed as GitPack's help describes.
#-------------------------------------------------------------------------------

#-------------------------------------------------------------------------------
# MAIN FUNCTION
#-------------------------------------------------------------------------------

# DESCRIPTION:
#   This is the GitPack entry point and it is expected to be executed first, yet
#   its calling should be at the end of this script.
# PARAMETERS:
#   $@ - GitPack arguments
main() {
    check_sw_deps &&
    init_constants &&
    init_strings &&
    init_config &&
    store_command "$0 $*" &&
    process_args "$@" # process all given GitPack arguments
}

# DESCRIPTION:
#   Checks whether all software dependencies are satisfied.
check_sw_deps() {
    # a list of required software
    sw_deps='command echo [ cd test pwd rm id mkdir touch grep git uname read cp
             head cut true basename find rmdir tr date tail kill sort getopts'

    # check if any piece of software is missing
    for sw_dep in $sw_deps; do
        if ! command -v "$sw_dep" > /dev/null; then
            echo "missing $sw_dep software" >&2; return 1
        fi
    done
}

#-------------------------------------------------------------------------------
# STATIC INITIALIZATION
#-------------------------------------------------------------------------------
# All constants of this section can be read in other code.
#-------------------------------------------------------------------------------

# DESCRIPTION:
#   Initializes static constants. They must not be changed later.
# shellcheck disable=SC2209
init_constants() {
    # the current version of GitPack
    VERSION=0.6.0

    # GitPack actions
    ACTION_INSTALL=install
    ACTION_UNINSTALL=uninstall
    ACTION_STATUS=status

    # project states of install action
    STATE_INSTALL=install # just installed
    STATE_UPDATE=update # just updated
    STATE_DOWNGRADE=downgrade # just downgraded
    STATE_CHANGE=change # just changed
    STATE_INSTALLED=installed # already installed
    # project states of uninstall action
    STATE_UNINSTALL=uninstall # just uninstalled
    STATE_UNINSTALLED=uninstalled # already uninstalled
    # project states of status action
    STATE_NOTHING=nothing # project is not installed
    STATE_OLDER=older # current version is older than target version
    STATE_NEWER=newer # current version is newer than target version
    STATE_DIFF=diff # current version is incomparable to target version
    STATE_OK=ok # current version is equal to target version

    # global log types
    LOGTYPE_LOG=log # logging initialization
    LOGTYPE_FAIL=fail # any recorder fail
    LOGTYPE_SIGNAL=signal # a handled signal
    LOGTYPE_EXIT=exit # exit the program
    # command log types
    LOGTYPE_LIST=list # list command
    LOGTYPE_CLEAN=clean # clean command
    LOGTYPE_PATHS=paths # paths command
    # action log types
    LOGTYPE_ACTION=action # action processing
    LOGTYPE_URL=url # URL check
    LOGTYPE_REPO=repo # repository initialization
    LOGTYPE_EXECUTE=execute # action executing
    LOGTYPE_DEPS=deps # processing dependencies
    # database log types
    LOGTYPE_DB=db # database initialization
    LOGTYPE_GET=get # get database item
    LOGTYPE_INSERT=insert # insert a database item
    LOGTYPE_DELETE=delete # delete database items
    LOGTYPE_BACKUP=backup # backup database
    # installation log types
    LOGTYPE_PRECP=precp # precp script execution
    LOGTYPE_CP=cp # copy files using map
    LOGTYPE_POSTCP=postcp # postcp script execution
    # uninstallation log types
    LOGTYPE_PRERM=prerm # prerm script execution
    LOGTYPE_RM=rm # remove files using map
    LOGTYPE_POSTRM=postrm # postrm script execution

    # dependency constants
    DEP_PREFIX='+ ' # prefix for processing dependencies

    # Git fetch remote refspecs
    HEAD_REFSPEC='+HEAD:refs/remotes/origin/HEAD' # HEAD
    TAG_REFSPEC='+refs/tags/*:refs/remotes/origin/tag/*' # tags
    BRANCH_REFSPEC='+refs/heads/*:refs/remotes/origin/branch/*' # branches
}

# DESCRIPTION:
#   Initializes strings usually used to display reports to the user. They must
#   not be changed later. Constants must be already initialized.
init_strings() {
    HELP_MESSAGE="USAGE:
  gitpack ACTION [OPTION...] URL[=VERSION]...
  gitpack COMMAND

ACTION:
  $ACTION_INSTALL    install/update projects
  $ACTION_UNINSTALL  uninstall projects
  $ACTION_STATUS     get status of projects

OPTION:
  -o  offline mode

VERSION:
  HEAD, tag/TAG, branch/BRANCH, COMMIT

COMMAND:
  list   list installed projects
  clean  clean files
  paths  show paths
  help   show help
  about  show information"

    ABOUT_MESSAGE="GitPack $VERSION
The simplest Git-based package manager.

Copyright 2019 Dominik Salvet
github.com/dominiksalvet/gitpack"
}

# DESCRIPTION:
#   Initializes GitPack configuration constants. They must not be changed later.
init_config() {
    LOG_LINES_KEPT=1000 # when shortening the log file, keep those last lines
    MAX_DEP_DEPTH=20 # max depth of dependencies prevents cyclic dependencies
}

# DESCRIPTION:
#   Stores a copy of a given command, which invoked this GitPack instance. That
#   value must not be changed later.
# PARAMETERS:
#   $@ - complete GitPack command
store_command() {
    COMMAND="$*" # the complete current GitPack command
}

#-------------------------------------------------------------------------------
# ARGUMENT PROCESSING
#-------------------------------------------------------------------------------

# DESCRIPTION:
#   Processes given GitPack arguments and performs all associated operations.
# PARAMETERS:
#   $@ - GitPack arguments
process_args() {
    case "$1" in # process arguments based on the first argument
        "$ACTION_INSTALL" | "$ACTION_UNINSTALL" | "$ACTION_STATUS")
            process_action_args "$@" ;; # process action-based arguments
        list) init_runtime && list ;;
        clean) init_runtime && clean ;;
        paths) init_runtime && paths ;;
        help) echo "$HELP_MESSAGE"; return ;;
        about) echo "$ABOUT_MESSAGE"; return ;;
        '') echo 'no argument provided' >&2; return 1 ;;
        *) echo "invalid argument $1" >&2; return 1 ;;
    esac &&

    backup_db # if success, back up the GitPack database
}

# DESCRIPTION:
#   Processes a given action and its arguments.
# PARAMETERS:
#   $1 - action
#   $@ - action arguments
process_action_args() {
    init_runtime && # initialize runtime
    action="$1" && # use the given action
    shift && # shift to action arguments

    process_action_opts "$@" && # action options (sets the OPTIND variable)
    shift "$((OPTIND - 1))" && # shift to reference arguments
    if [ "$#" -eq 0 ]; then # check if there is any reference argument
        echof 'no URL provided'; return 1
    fi &&

    for ref in "$@"; do # process each reference individually with common action
        process_action "$action" "$ref" || return
    done
}

# DESCRIPTION:
#   Processes given arguments as action options. It sets the OPTIND variable
#   holding the position of the following argument.
# PARAMETERS:
#   $@ - action arguments
process_action_opts() {
    while getopts :o opt; do # for each option argument
        case "$opt" in
            o)  OFFLINE_MODE=true ;;
            \?) echof "invalid option -$OPTARG"; return 1 ;;
        esac
    done
}

# DESCRIPTION:
#   Prints given echo arguments to standard error stream and logs the same into
#   the GitPack log file as a fail.
# PARAMETERS:
#   $@ - echo arguments
echof() {
    echo "$@" >&2 # print the fail
    log "$LOGTYPE_FAIL" "$@" # log the fail
}

#-------------------------------------------------------------------------------
# DYNAMIC INITIALIZATION
#-------------------------------------------------------------------------------
# All constants of this section can be read in other code. All global and
# environment variables of this section can be accessed in other code.
#-------------------------------------------------------------------------------

# DESCRIPTION:
#   Initializes a runtime environment for GitPack. After calling this function,
#   GitPack's environment, logging and file structure will be prepared.
init_runtime() {
    init_global_vars &&
    init_env_vars &&
    init_paths &&
    init_logging && # logging starts from here
    init_traps &&
    init_db
}

# DESCRIPTION:
#   Initializes all global variables. If there is a global variable, it must be
#   stated here even though its value is going to be overwritten.
init_global_vars() {
    user_id="$(id -u)" && # check if running as root, not a global variable
    # based on previous result, set up the access level
    if [ "$user_id" -eq 0 ]; then
        access=global
    else
        access=local
    fi &&
    system="$(uname)" && # get the current system name

    state= && # the state of the processed project
    dep_depth=0 # current dependency depth
}

# DESCRIPTION:
#   Initializes all environment variables. They can be read in called scripts.
init_env_vars() {
    export OFFLINE_MODE=false # GitPack offline mode
}

# DESCRIPTION:
#   Initializes all GitPack-specific paths. They must start with '/' and must
#   not be changed later.
init_paths() {
    # initialize directory paths
    if [ "$access" = global ]; then # respect FHS
        LOG_DIR=/var/log/gitpack
        CACHE_DIR=/var/cache/gitpack
        STATE_DIR=/var/lib/gitpack
    else # respect XDG
        LOG_DIR=~/.local/share/gitpack
        CACHE_DIR=~/.cache/gitpack
        STATE_DIR=~/.local/share/gitpack
    fi

    # initialize derived paths
    LOG_PATH="$LOG_DIR"/gitpack.log # the execution log file
    CACHE_REPO_DIR="$CACHE_DIR"/repo # the cache for local Git repositories
    STATUS_PATH="$STATE_DIR"/status # the database of installed projects
    STATUS_BAK_PATH="$STATE_DIR"/status.bak # the database backup
}

# DESCRIPTION:
#   Initializes traps of all handled signals in GitPack.
init_traps() {
    trap 'log "$LOGTYPE_EXIT" "$?"' EXIT && # log GitPack exit status on exit
    trap term_action HUP INT QUIT TERM # handle termination signals
}

# DESCRIPTION:
#   This function is expected to handle all termination signals that can be sent
#   to GitPack. It logs the signal name and exits with its exit status.
term_action() {
    status="$?" # get exit status of the signal
    log "$LOGTYPE_SIGNAL" "SIG$(kill -l "$status")" # log signal name
    exit "$status" # exit GitPack (it also invokes the EXIT trap)
}

#-------------------------------------------------------------------------------
# COMMAND PROCESSING
#-------------------------------------------------------------------------------

# DESCRIPTION:
#   Prints all installed Git projects and their versions or commit hashes.
list() {
    log "$LOGTYPE_LIST" "$STATUS_PATH" &&
    while read -r db_record; do
        url="${db_record%% *}" # extract URL
        version="${db_record#* }" # extract commit hash
        version="$(beautify_hash "$url" "$version")" && # try to beautify it
        echo "$url $version" || return
    done < "$STATUS_PATH"
}

# DESCRIPTION:
#   Cleans the GitPack cache and log performing checks for unintended removal.
clean() {
    # log clean operation, also creates a log file if it does not exist
    log "$LOGTYPE_CLEAN" "$CACHE_DIR"/ &&

    # clean log shortening it to a defined number of last lines
    tail_out="$(tail -n "$LOG_LINES_KEPT" "$LOG_PATH")" &&
    echo "$tail_out" > "$LOG_PATH" && # write changes back to the log file

    # clean Git cache
    if ! remove_dir "$CACHE_DIR"; then # in case of fail
        echof 'failed to remove cache directory'; return 1
    fi
}

# DESCRIPTION:
#   Prints all GitPack-specific paths.
paths() {
    log "$LOGTYPE_PATHS" &&
    echo "log $LOG_DIR/" &&
    echo "cache $CACHE_DIR/" &&
    echo "state $STATE_DIR/"
}

# DESCRIPTION:
#   Removes a given directory recursively if it exists. It also prevents from
#   removing the root and home directories and there are performed additional
#   checks related to safety of the whole process.
# PARAMETERS:
#   $1 - directory
remove_dir() {
    test "$1" && # the directory path must not be empty
    if [ -d "$1"/ ]; then # check if the directory exists
        (   # store physical path of the given directory
            cd -- "$1"/ && pwd_out="$(pwd -P)" &&

            # check for the root directory
            test "$PWD" != / && test "$pwd_out" != / &&
            # check for the root directory (with two slashes)
            test "$PWD" != // && test "$pwd_out" != // &&
            # check for a home directory
            test "$PWD" != ~ && test "$pwd_out" != ~
        ) &&
        rm -fr -- "${1:?}"/ # remove the directory itself recursively
    fi
}

#-------------------------------------------------------------------------------
# ACTION PROCESSING
#-------------------------------------------------------------------------------

# DESCRIPTION:
#   Performs several checks, prepares target Git repository and executes the
#   given action itself. Requires GitPack's runtime to be already initialized.
#   Also prints a report after the execution.
# PARAMETERS:
#   $1 - action
#   $2 - reference
process_action() {
    {   # log current action processing
        log "$LOGTYPE_ACTION" "$1" "$2" &&
        # process given reference - URL + optional version
        url="$(ref_to_url "$2")" &&
        version="$(ref_to_version "$2")" &&
        check_url "$url" &&

        # prepare Git repository
        init_repo "$url" &&

        # execute the action itself
        execute_action "$1" "$url" "$version"
    } || {
        # all possible errors during action processing are caught here
        action_status="$?" # store the action exit status
        echo "$(get_dep_prefix)<ERROR> $1 $2" >&2 # report GitPack information
        return "$action_status" # propagate the status further
    }
}

# DESCRIPTION:
#   Extracts and normalizes the URL from a given reference.
# PARAMETERS:
#   $1 - reference
ref_to_url() {
    url="${1%%=*}" # remove version if any
    url="${url#https://}" # remove https:// prefix
    url="${url%.git}" # remove .git suffix
    echo "$url" | tr '[:upper:]' '[:lower:]' # to lowercase
}

# DESCRIPTION:
#   Extracts a version from a given reference if there is any. Always succeeds.
# PARAMETERS:
#   $1 - reference
ref_to_version() {
    version="${1#*=}" # remove URL and keep version
    if [ "$version" != "$1" ]; then # check if there was a version
        echo "$version"
    fi
}

# DESCRIPTION:
#   Checks whether a given URL is supported.
# PARAMETERS:
#   $1 - URL
check_url() {
    log "$LOGTYPE_URL" "$1" || return
    url_regex='^[[:alnum:]_][[:alnum:]_\.-]*(/[[:alnum:]_][[:alnum:]_\.-]*){2}$'

    if ! echo "$1" | grep -qE "$url_regex"; then
        echof 'unsupported URL delivered'; return 1
    fi
}

#-------------------------------------------------------------------------------
# REPOSITORY
#-------------------------------------------------------------------------------

# DESCRIPTION:
#   Initializes a Git repository of a given URL into a directory in the GitPack
#   cache. The repository will be downloaded unless the offline mode is enabled,
#   in which case succeeds only if it is already downloaded.
# PARAMETERS:
#   $1 - URL
init_repo() {
    repo_dir="$(url_to_path "$1")" && # get the repository directory path
    log "$LOGTYPE_REPO" "$1" "$repo_dir"/ &&

    if [ "$OFFLINE_MODE" = true ]; then # offline
        if [ ! -d "$repo_dir"/ ]; then # fail if local repository does not exist
            echof 'repository is not downloaded'; return 1
        fi
    else # online
        fetch_repo "$1" "$repo_dir"
    fi
}

# DESCRIPTION:
#   Downloads files of a given repository URL so that they are up to date. If an
#   appropriate local repository does not exist, it is created and configured.
#   Then, remote updates are fetched including any reference removal.
# PARAMETERS:
#   $1 - URL
#   $2 - repository directory
fetch_repo() { (
    if [ -d "$2"/ ]; then # local repository already exists
        cd "$2"/
    else # create and configure local repository
        mkdir -p "$2"/ && cd "$2"/ && # create a directory
        # create and configure the Git repository
        git init -q && # create it
        git config gc.auto 0 && # disable automatic Git garbage collection
        git config remote.origin.url https://"$1".git && # add remote URL
        git config remote.origin.fetch "$HEAD_REFSPEC" && # HEAD
        git config --add remote.origin.fetch "$TAG_REFSPEC" && # tags
        git config --add remote.origin.fetch "$BRANCH_REFSPEC" # branches
    fi &&
    # fetch remote updates (prune references and do not fetch tags implicitly)
    git fetch -pnq origin # it may ask for a password
) }

# DESCRIPTION:
#   Transforms a given URL of a Git repository to an actual path where the local
#   repository is stored.
# PARAMETERS:
#   $1 - URL
url_to_path() {
    echo "$CACHE_REPO_DIR"/"$1"
}

#-------------------------------------------------------------------------------
# CHOOSE ACTION
#-------------------------------------------------------------------------------

# DESCRIPTION:
#   Chooses which action will be executed and executes it with an initialized
#   Git repository. If no version is delivered, GitPack chooses the preferred
#   commit instead. Also prints a report after the execution.
# PARAMETERS:
#   $1 - action
#   $2 - URL
#   $3 - version (optional)
execute_action() {
    log "$LOGTYPE_EXECUTE" "$1" "$2" "$3" &&
    # get source (already installed) project information
    src_db_record="$(get_db_record "$2")" &&
    src_hash="${src_db_record#* }" && # extract commit hash
    # get target (installation candidate) project information
    tar_hash="$(get_repo_hash "$2" "$3")" &&

    # process dependencies first
    process_deps "$1" "$2" "$tar_hash" &&

    # choose action and execute it
    case "$1" in
        "$ACTION_INSTALL") execute_install "$2" "$src_hash" "$tar_hash" ;;
        "$ACTION_UNINSTALL") execute_uninstall "$2" "$src_hash" ;;
        "$ACTION_STATUS") execute_status "$2" "$src_hash" "$tar_hash" ;;
    esac &&

    report "$state" "$2" "$src_hash" "$tar_hash"
}

# DESCRIPTION:
#   Prints a preferred commit hash of a given project. Respecting the default
#   branch, chooses its latest tag's commit (preferred) or latest commit.
# PARAMETERS:
#   $1 - URL
#   $2 - version (optional)
get_repo_hash() { (
    repo_cd "$1" &&

    if [ "$2" ]; then # if any version has been provided
        # print the hash of the version if it is a valid Git commit reference
        if ! git rev-parse --verify -q origin/"$2"'^{commit}' && # references
           ! git rev-parse --verify -q "$2"'^{commit}'; then # commit
            echof "version $2 does not exist"; return 1
        fi
    else # detect a preferred commit
        # get latest tag (preferred) or latest commit of the default branch
        commit="$(git describe --all --abbrev=0 --match 'origin/tag/*' \
                               --always origin/HEAD)" &&
        git rev-parse --verify "$commit"'^{commit}' # get commit hash
    fi
) }

# DESCRIPTION:
#   Changes current working directory to a given repository and checkouts its
#   given commit. If the commit parameter is empty, no checkout is performed.
# PARAMETERS:
#   $1 - URL
#   $2 - commit (optional)
repo_cd() {
    cd "$(url_to_path "$1")"/ && # transform the given URL to path
    if [ "$2" ]; then
        git checkout -q "$2"
    fi
}

#-------------------------------------------------------------------------------
# DEPENDENCIES
#-------------------------------------------------------------------------------

# DESCRIPTION:
#   Prints the current prefix for dependency reports considering the current
#   dependency depth value.
get_dep_prefix() {
    if [ "$dep_depth" -gt 0 ]; then
        echo "$DEP_PREFIX"
    fi
}

# DESCRIPTION:
#   Processes all dependencies of a given project considering a given action. It
#   also checks whether a defined dependency depth was not exceeded.
# PARAMETERS:
#   $1 - action
#   $2 - URL
#   $3 - commit
process_deps() {
    if [ "$1" = "$ACTION_UNINSTALL" ]; then
        return 0 # early return in the uninstall case
    fi

    deps="$(get_deps "$2" "$3")" && # get all dependencies
    # run the given action recursively for each dependency reference
    echon "$deps" | while read -r dep; do # run them in separate subshells
        (   next_dep_depth && # register a new dependency depth level
            process_action "$1" "$dep"
        ) || return
    done
}

# DESCRIPTION:
#   Prints all dependencies of a given project's URL and commit if any.
# PARAMETERS:
#   $1 - URL
#   $2 - commit
get_deps() { (
    repo_cd "$1" "$2" &&
    # if there is a file describing dependencies
    if [ -r .gitpack/deps ]; then
        log "$LOGTYPE_DEPS" "$1" "$2" &&
        grepe '^[^#]' .gitpack/deps # remove empty and comment lines
    fi
) }

# DESCRIPTION:
#   Prepares the environment for a new dependency depth level. It also checks
#   whether it is possible to continue processing dependencies.
next_dep_depth() {
    dep_depth="$((dep_depth + 1))" # increment dependency depth

    # check whether the new dependency depth value is valid
    if [ "$dep_depth" -gt "$MAX_DEP_DEPTH" ]; then
        echof 'maximum dependency depth reached'; return 1
    fi
}

# DESCRIPTION:
#   An echo wrapper. It does not print a new line if the final string is empty.
# PARAMETERS:
#   $@ - echo arguments
echon() {
    if [ "$@" ]; then
        echo "$@"
    fi
}

# DESCRIPTION:
#   This function is a grep wrapper. Succeeds even in the case of an empty grep
#   selection.
# PARAMETERS:
#   $@ - grep arguments
grepe() {
    grep "$@" # execute the grep itself
    grep_status="$?" # store its exit status

    # suppress the empty selection error indicator (exit status of 1)
    if [ "$grep_status" -eq 1 ]; then
        grep_status=0
    fi
    return "$grep_status" # return the modified exit status
}

#-------------------------------------------------------------------------------
# EXECUTE ACTION
#-------------------------------------------------------------------------------

# DESCRIPTION:
#   Decides whether install, change, or do nothing with a given project. If any
#   operation is done, it will use only given commits and also updates the
#   GitPack database.
# PARAMETERS:
#   $1 - URL
#   $2 - source commit (optional)
#   $3 - target commit
execute_install() {
    if [ ! "$2" ]; then # no source version
        state="$STATE_INSTALL" &&
        install "$1" "$3" && # install target commit
        insert_db_record "$1" "$3" # update GitPack database
    elif [ "$2" = "$3" ]; then # given versions are equal
        state="$STATE_INSTALLED"
    else # given version are different
        execute_change "$1" "$2" "$3"
    fi
}

# DESCRIPTION:
#   Changes version of a given project from a given source commit to a given
#   target commit and updates the GitPack database.
# PARAMETERS:
#   $1 - URL
#   $2 - source commit
#   $3 - target commit
execute_change() {
    if is_ancestor_commit "$1" "$2" "$3"; then # source version is older
        state="$STATE_UPDATE"
    elif is_ancestor_commit "$1" "$3" "$2"; then # source version is newer
        state="$STATE_DOWNGRADE"
    else # given versions are not comparable (different branches)
        state="$STATE_CHANGE"
    fi &&

    uninstall "$1" "$2" && # uninstall source commit
    delete_db_records "$1" && # update GitPack database
    install "$1" "$3" && # install target commit
    insert_db_record "$1" "$3" # update GitPack database
}

# DESCRIPTION:
#   Decides whether uninstall, or do nothing with a given project. If any
#   operation is done, it will use only given commit and also updates the
#   GitPack database.
# PARAMETERS:
#   $1 - URL
#   $2 - commit (optional)
execute_uninstall() {
    if [ "$2" ]; then # if installed
        state="$STATE_UNINSTALL" &&
        uninstall "$1" "$2" && # uninstall given commit
        delete_db_records "$1" # update GitPack database
    else # no source version
        state="$STATE_UNINSTALLED"
    fi
}

# DESCRIPTION:
#   Checks a given repository considering given source and target commits. It
#   always succeeds.
# PARAMETERS:
#   $1 - URL
#   $2 - source commit (optional)
#   $3 - target commit
execute_status() {
    if [ ! "$2" ]; then # no source version
        state="$STATE_NOTHING"
    elif [ "$2" = "$3" ]; then # given versions are equal
        state="$STATE_OK"
    elif is_ancestor_commit "$1" "$2" "$3"; then # source version is older
        state="$STATE_OLDER"
    elif is_ancestor_commit "$1" "$3" "$2"; then # source version is newer
        state="$STATE_NEWER"
    else # given versions are not comparable (different branches)
        state="$STATE_DIFF"
    fi
}

# DESCRIPTION:
#   Checks whether the first given commit is an ancestor of the second commit in
#   a given Git repository.
# PARAMETERS:
#   $1 - URL
#   $2 - first commit
#   $3 - second commit
is_ancestor_commit() { (
    repo_cd "$1" &&
    git merge-base --is-ancestor "$2" "$3"
) }

#-------------------------------------------------------------------------------
# INSTALLATION AND UNINSTALLATION
#-------------------------------------------------------------------------------

# DESCRIPTION:
#   Installs a project based on a given repository URL and commit.
# PARAMETERS:
#   $1 - URL
#   $2 - commit
install() { (
    repo_cd "$1" "$2" &&
    install_dir="$(get_install_dir)" && # get preferred installation directory
    install_method="$(basename -- "$install_dir"/)" && # installation method

    if [ -x "$install_dir"/precp ]; then # before files copy
        log "$LOGTYPE_PRECP" "$1" "$2" "$install_method" &&
        run_script "$install_dir"/precp
    fi &&

    # copy all files using the preferred map
    log "$LOGTYPE_CP" "$1" "$2" "$install_method" &&
    for_each_route "$install_dir"/map copy_files_to_dir &&

    if [ -x "$install_dir"/postcp ]; then # after files copy
        log "$LOGTYPE_POSTCP" "$1" "$2" "$install_method" &&
        run_script "$install_dir"/postcp
    fi
) }

# DESCRIPTION:
#   Uninstalls a project based on a given repository URL and commit.
# PARAMETERS:
#   $1 - URL
#   $2 - commit
uninstall() { (
    repo_cd "$1" "$2" &&
    install_dir="$(get_install_dir)" && # get preferred installation directory
    install_method="$(basename -- "$install_dir"/)" && # uninstallation method

    if [ -x "$install_dir"/prerm ]; then # before files removal
        log "$LOGTYPE_PRERM" "$1" "$2" "$install_method" &&
        run_script "$install_dir"/prerm
    fi &&

    # remove all files using the preferred map
    log "$LOGTYPE_RM" "$1" "$2" "$install_method" &&
    for_each_route "$install_dir"/map remove_files_from_dir &&

    if [ -x "$install_dir"/postrm ]; then # after files removal
        log "$LOGTYPE_POSTRM" "$1" "$2" "$install_method" &&
        run_script "$install_dir"/postrm
    fi
) }

# DESCRIPTION:
#   Prints the relative path of the appropriate GitPack installation directory
#   based on the current runtime and system information.
get_install_dir() {
    if [ -d .gitpack/install/"${access}-$system"/ ]; then
        echo .gitpack/install/"${access}-$system" # system-specific directory
    else
        echo .gitpack/install/"$access" # system-independent directory
    fi
}

# DESCRIPTION:
#   Runs a given script. In case of an error, prints and logs a fail report.
# PARAMETERS:
#   $1 - script path
run_script() {
    "$1" && return # run the script and return early if it exited successfully

    script_status="$?" # store the exit status of the failed script
    echof "$(basename -- "$1") script failed with $script_status"
    return 1 # indicate error but do not propagate the exit status further
}

#-------------------------------------------------------------------------------
# COPY FILES
#-------------------------------------------------------------------------------

# DESCRIPTION:
#   For each given map route, it calls a given function. It also prepares the
#   map by removing comments and empty lines before calling any function so that
#   it contains only required routes.
# PARAMETERS:
#   $1 - map path
#   $2 - function name
for_each_route() { (
    if [ -r "$1" ]; then # check whether the map file exists
        grepe_out="$(grepe '^[^#]' "$1")" && # remove empty and comment lines
        # call a given function for each route
        echon "$grepe_out" | while read -r route; do
            eval "$2" "$route" || return
        done
    else # if the map file does not exist, fails
        echof 'missing map file'; return 1
    fi
) }

# DESCRIPTION:
#   Copies given files recursively to a given target directory. It also creates
#   all intermediate directories necessary.
# PARAMETERS:
#   $@ - file paths
#   -$1 - target directory
copy_files_to_dir() {
    target_dir="$(get_last_arg "$@")" &&
    mkdir -p -- "$target_dir" && # create target directory
    cp -R -- "$@" # copy files recursively into to
}

# DESCRIPTION:
#   Prints the last argument of all given arguments.
# PARAMETERS:
#   $@ - arguments
get_last_arg() {
    shift "$(($# - 1))" && # shift to the last argument
    echo "$1" # print it
}

#-------------------------------------------------------------------------------
# REMOVE FILES
#-------------------------------------------------------------------------------

# DESCRIPTION:
#   Removes the copies of given files from a given target directory. Then, also
#   removes all empty directories in the target directory pathname.
# PARAMETERS:
#   $@ - file paths
#   -$1 - target directory
remove_files_from_dir() {
    # get the target directory to remove files from
    target_dir="$(get_last_arg "$@")" &&
    test "$target_dir" &&

    while [ "$#" -gt 1 ]; do # for each file path argument
        test "$1" &&
        remove_file_from_dir "$1" "$target_dir" && # remove the file
        rmdirf -p -- "${target_dir:?}"/ && # remove empty pathname directories
        shift || return # shift to next argument
    done
}

# DESCRIPTION:
#   Removes the copy of a given file from a given target directory. In case of a
#   directory, its content is removed in accordance with the original directory.
# PARAMETERS:
#   $1 - file path
#   $2 - target directory
remove_file_from_dir() {
    test "$1" && test "$2" &&

    if [ -d "$1"/ ]; then
        remove_dir_from_dir "$1" "$2"
    else
        file_name="$(basename -- "$1")" && # name of the file to be removed
        # remove the file from the target directory
        rm -f -- "${2:?}"/"${file_name:?}"
    fi
}

# DESCRIPTION:
#   Removes the copy of a given directory from a given target directory. It uses
#   the contents of the given directory as a file mask controlling the process
#   of file removing in the target directory.
# PARAMETERS:
#   $1 - directory
#   $2 - target directory
remove_dir_from_dir() {
    test "$1" && test "$2" &&
    dir_name="$(basename -- "$1")" && # name of the directory to be removed

    # scan the target directory to obtain a file mask (files and directories)
    files="$(cd -- "$1"/ && find ./ ! -type d)" &&
    dirs="$(cd -- "$1"/ && find ./ -type d ! -path ./ | sort -r)" &&

    echon "$files" | while read -r file; do # remove files using file mask
        rm -f -- "${2:?}"/"${dir_name:?}"/"${file:?}" || return
    done &&
    echon "$dirs" | while read -r dir; do # remove directories using file mask
        rmdirf -- "${2:?}"/"${dir_name:?}"/"${dir:?}"/ || return
    done &&
    rmdirf -- "${2:?}"/"${dir_name:?}"/ # remove the copied directory itself
}

# DESCRIPTION:
#   This function is a rmdir wrapper. It succeeds even in case the target
#   directories do not exist.
# PARAMETERS:
#   $@ - rmdir arguments
rmdirf() {
    # suppress error output and always succeeds
    rmdir "$@" 2>/dev/null; true
}

#-------------------------------------------------------------------------------
# DATABASE
#-------------------------------------------------------------------------------

# DESCRIPTION:
#   Initializes GitPack database file structure based on prepared global
#   variables. It fails if it cannot create a file or GitPack does not have read
#   or write permissions.
init_db() {
    log "$LOGTYPE_DB" "$STATUS_PATH" &&
    mkdir -p "$STATE_DIR"/ && # create the state directory
    # create GitPack status file if it does not exist
    if [ ! -e "$STATUS_PATH" ]; then
        if [ -r "$STATUS_BAK_PATH" ]; then # if there is a status file backup
            cp "$STATUS_BAK_PATH" "$STATUS_PATH" # recover from the backup
        else
            touch "$STATUS_PATH" # create a new status file
        fi
    fi &&

    # check access to GitPack status file
    if [ ! -r "$STATUS_PATH" ] || [ ! -w "$STATUS_PATH" ]; then
        echof 'cannot access status file'; return 1
    fi
}

# DESCRIPTION:
#   Selects the first record matching a given URL from the GitPack database.
# PARAMETERS:
#   $1 - URL
get_db_record() {
    log "$LOGTYPE_GET" "$1" "$STATUS_PATH" &&
    grepe_out="$(grepe -F "$1" "$STATUS_PATH")" &&
    echon "$grepe_out" | head -n 1
}

# DESCRIPTION:
#   Inserts a given installation record into the GitPack database.
# PARAMETERS:
#   $1 - URL
#   $2 - commit
insert_db_record() {
    log "$LOGTYPE_INSERT" "$1" "$2" "$STATUS_PATH" &&
    echo "$1 $2" >> "$STATUS_PATH"
}

# DESCRIPTION:
#   Deletes all installation records with given URL from the GitPack database.
# PARAMETERS:
#   $1 - URL
delete_db_records() {
    log "$LOGTYPE_DELETE" "$1" "$STATUS_PATH" &&
    grepe_out="$(grepe -Fv "$1" "$STATUS_PATH")" &&
    echon "$grepe_out" > "$STATUS_PATH"
}

# DESCRIPTION:
#   Backs up the GitPack database by copying it to a different path.
backup_db() {
    log "$LOGTYPE_BACKUP" "$STATUS_PATH" "$STATUS_BAK_PATH" &&
    cp "$STATUS_PATH" "$STATUS_BAK_PATH"
}

#-------------------------------------------------------------------------------
# LOGGING
#-------------------------------------------------------------------------------

# DESCRIPTION:
#   Creates logging file structure and logs the initialization log item.
init_logging() {
    mkdir -p "$LOG_DIR"/ && # create the log directory
    log "$LOGTYPE_LOG" "$COMMAND"
}

# DESCRIPTION:
#   Creates a new log item in the predefined log file with current date and time
#   based on a given type and details.
# PARAMETERS:
#   $1 - type
#   $@ - details (optional)
log() {
    log_time="$(date '+%Y-%m-%d %H:%M:%S')" && # catch time immediately
    logtype="$1" && # use the given log type
    shift && # shift arguments to details

    details= && # start with no details
    for detail in "$@"; do # get all details
        if [ "$detail" ]; then # ignore empty ones
            details="$details $detail"
        fi
    done &&

    # store the log item
    echo "$log_time [$logtype]$details" >> "$LOG_PATH"
}

#-------------------------------------------------------------------------------
# REPORT
#-------------------------------------------------------------------------------

# DESCRIPTION:
#   Prints a report of a given Git project and all associated parameters.
# PARAMETERS:
#   $1 - state
#   $2 - URL
#   $3 - source commit
#   $4 - target commit
report() {
    # prepare given arguments
    prefix="$(get_dep_prefix)[$1] $2" &&
    src_version="$(beautify_hash "$2" "$3")" &&
    tar_version="$(beautify_hash "$2" "$4")" &&

    case "$1" in
        "$STATE_INSTALL") echo "$prefix $tar_version" ;;
        "$STATE_UPDATE" | "$STATE_DOWNGRADE" | "$STATE_CHANGE")
            echo "$prefix $tar_version <- $src_version" ;;
        "$STATE_INSTALLED" | "$STATE_UNINSTALL" | "$STATE_OK")
            echo "$prefix $src_version" ;;
        "$STATE_UNINSTALLED") echo "$prefix" ;;
        "$STATE_NOTHING") echo "$prefix -> $tar_version" ;;
        "$STATE_OLDER" | "$STATE_NEWER" | "$STATE_DIFF")
            echo "$prefix $src_version -> $tar_version" ;;
    esac
}

# DESCRIPTION:
#   Beautifies a given commit hash. If there is a Git reference associated with
#   the given hash, prints its name. Otherwise, it shortens the given hash.
#   Always succeeds.
# PARAMETERS:
#   $1 - URL
#   $2 - commit
beautify_hash() { (
    # check if given hash is associated with any reference
    if repo_cd "$1" 2>/dev/null &&
       ref="$(git describe --all --exact-match "$2" 2>/dev/null)"; then
        echo "${ref#remotes/origin/}" # remove reference prefix
    else # if no reference found, return short hash
        echo "$2" | cut -c 1-7
    fi
) }

#-------------------------------------------------------------------------------
# CALL MAIN
#-------------------------------------------------------------------------------

main "$@" # call the main function, having all functions above already defined
