#!/bin/sh

#-------------------------------------------------------------------------------
# Copyright 2019 Dominik Salvet
# SPDX-License-Identifier: MIT
# https://github.com/dominiksalvet/gitpack
#-------------------------------------------------------------------------------
# DESCRIPTION:
#   This is the main file of GitPack - Git-based package manager.
# PARAMETERS:
#   All given arguments are processed as GitPack's help describes.
#-------------------------------------------------------------------------------

#-------------------------------------------------------------------------------
# ENTRY POINT
#-------------------------------------------------------------------------------

# DESCRIPTION:
#   This is the GitPack entry point and it is expected to be executed first, yet
#   its calling should be at the end of this script.
# PARAMETERS:
#   $@ - GitPack arguments
main() {
    check_sw_deps &&
    init_constants &&
    init_strings &&
    init_configuration "$@" &&
    process_args "$@"
}

#-------------------------------------------------------------------------------
# SOFTWARE DEPENDENCIES
#-------------------------------------------------------------------------------

# DESCRIPTION:
#   Checks whether all software dependencies are satisfied.
check_sw_deps() {
    # a list of required software
    sw_deps='command echo [ cd test pwd rm id mkdir touch dirname grep git ls
             uname read cp head cut true basename find rmdir tr date tail kill
             sleep wait'

    # check if any piece of software is missing
    for sw_dep in $sw_deps; do
        if ! command -v "$sw_dep" > /dev/null; then
            echo "missing $sw_dep software" >&2
            return 1
        fi
    done
}

#-------------------------------------------------------------------------------
# STATIC INITIALIZATION
#-------------------------------------------------------------------------------
# All constants of this section can be read in other code.
#-------------------------------------------------------------------------------

# DESCRIPTION:
#   Initializes static constants. They must not be changed later.
# shellcheck disable=SC2209
init_constants() {
    # the current version of GitPack
    VERSION=0.3.0

    # GitPack actions
    ACTION_INSTALL=install
    ACTION_UNINSTALL=uninstall
    ACTION_STATUS=status

    # project states of install action
    STATE_INSTALL=install # just installed
    STATE_UPDATE=update # just updated
    STATE_DOWNGRADE=downgrade # just downgraded
    STATE_INSTALLED=installed # already installed
    # project states of uninstall action
    STATE_UNINSTALL=uninstall # just uninstalled
    STATE_UNINSTALLED=uninstalled # already uninstalled
    # project states of status action
    STATE_NOTHING=nothing # project is not installed
    STATE_OLDER=older # current version is older than target version
    STATE_NEWER=newer # current version is newer than target version
    STATE_OK=ok # current version is equal to target version

    # global log types
    LOGTYPE_INIT=init # logging initialization
    LOGTYPE_FAIL=fail # any recorder fail
    LOGTYPE_SIGNAL=signal # a handled signal
    LOGTYPE_EXIT=exit # exit the program
    # command log types
    LOGTYPE_LIST=list # list command
    LOGTYPE_CLEAN=clean # clean command
    # action log types
    LOGTYPE_ACTION=action # action processing
    LOGTYPE_URL=url # URL check
    LOGTYPE_CLONE=clone # clone repository
    LOGTYPE_EXECUTE=execute # action executing
    LOGTYPE_DEPS=deps # processing dependencies
    # database log types
    LOGTYPE_GET=get # get database item
    LOGTYPE_INSERT=insert # insert a database item
    LOGTYPE_DELETE=delete # delete database items
    # installation log types
    LOGTYPE_PRECP=precp # precp script execution
    LOGTYPE_CP=cp # copy files using map
    LOGTYPE_POSTCP=postcp # postcp script execution
    # uninstallation log types
    LOGTYPE_PRERM=prerm # prerm script execution
    LOGTYPE_RM=rm # remove files using map
    LOGTYPE_POSTRM=postrm # postrm script execution

    # other constants
    SIGCHLD_EXIT_STATUS=145 # SIGCHLD number is 17, signals exit with 128+n
}

# DESCRIPTION:
#   Initializes strings usually used to display reports to the user. They must
#   not be changed later. Constants must be already initialized.
init_strings() {
    HELP_MESSAGE="USAGE:
  gitpack ACTION URL[=VERSION]...
  gitpack COMMAND

ACTION:
  $ACTION_INSTALL    install/update Git projects
  $ACTION_UNINSTALL  uninstall Git projects
  $ACTION_STATUS     show status of Git projects

COMMAND:
  list   list installed Git projects
  clean  clean cache and log
  help   show this help
  about  show information"

    ABOUT_MESSAGE="GitPack $VERSION
The simplest Git-based package manager.

Copy"'right 2019 Dominik Salvet
SPDX License Identifier: MIT
https://github.com/dominiksalvet/gitpack'
}

# DESCRIPTION:
#   Stores a copy of a complete command, which invoked this GitPack instance
#   based on given GitPack arguments and initializes other constants used as
#   a part of the GitPack configuration. None of them may be changed later.
# PARAMETERS:
#   $@ - GitPack arguments
init_configuration() {
    COMMAND="$0 $*" # the complete current GitPack command
    LOG_LINES_KEPT=1000 # when shortening the log file, keep those last lines
    SCRIPT_TIMEOUT=900 # timeout in seconds used when calling custom scripts
    MAX_DEP_DEPTH=20 # max depth of dependencies, prevent cyclic dependencies
}

#-------------------------------------------------------------------------------
# ARGUMENT PARSING
#-------------------------------------------------------------------------------

# DESCRIPTION:
#   Processes given GitPack arguments and performs all associated operations.
# PARAMETERS:
#   $@ - GitPack arguments
process_args() {
    case "$1" in # process arguments based on the first argument
        "$ACTION_INSTALL" | "$ACTION_UNINSTALL" | "$ACTION_STATUS")
            if [ "$#" -eq 1 ]; then # check if there is any reference argument
                echo 'no URL provided' >&2
                return 1
            fi
            init_runtime && # initialize runtime
            process_action_args "$@" # process action-based arguments
            ;;
        list) init_runtime && list_installed ;;
        clean) init_runtime && clean_cache ;;
        help) echo "$HELP_MESSAGE" ;;
        about) echo "$ABOUT_MESSAGE" ;;
        '') echo 'no argument provided' >&2; return 1 ;;
        *) echo "unrecognized argument $1" >&2; return 1 ;;
    esac
}

# DESCRIPTION:
#   Processes a given action over all given repository references.
# PARAMETERS:
#   $1 - action
#   $2.. - references
process_action_args() {
    action="$1" && # use the given action
    shift && # shift arguments to references
    for ref in "$@"; do # process each reference individually with common action
        process_action "$action" "$ref" || return
    done
}

# DESCRIPTION:
#   Outputs all installed Git projects and their version or commit hash.
list_installed() {
    log "$LOGTYPE_LIST" "$STATUS_PATH" &&
    while read -r db_record; do
        url="${db_record%% *}" # extract URL
        version="${db_record#* }" # extract commit hash
        version="$(beautify_hash "$url" "$version")" && # try to beautify it
        echo "$url $version" || return
    done < "$STATUS_PATH"
}

# DESCRIPTION:
#   Cleans the GitPack cache and log performing checks for unintended removal.
clean_cache() {
    # log clean operation, creates a log file if it does not exit
    log "$LOGTYPE_CLEAN" "$CACHE_REPO_DIR"/ &&

    # clean log shortening it to a defined number of last lines
    tail_out="$(tail -n "$LOG_LINES_KEPT" "$LOG_PATH")" &&
    echo "$tail_out" > "$LOG_PATH" && # write changes back to the log file

    # clean Git repository cache
    if [ -d "${CACHE_REPO_DIR:?}"/ ]; then # check if cache exists
        if rm_rf_dir_check "$CACHE_REPO_DIR"; then
            rm -rf -- "${CACHE_REPO_DIR:?}"/
        else
            echof 'prevent removing the root directory'
            return 1
        fi
    fi
}

# DESCRIPTION:
#   Checks whether it is possible to recursively remove a given directory. It
#   prevents from removing the root and home directories. This function uses
#   only the first parameter due to possible unintended globbing.
# PARAMETERS:
#   $1 - directory
rm_rf_dir_check() { (
    test "$1" && # the directory path must not be empty
    cd -- "$1"/ 2>/dev/null && # fails if the given directory doesn't exist
    pwd_out="$(pwd -P)" && # store physical path of the current directory

    # check for the root directory
    test "$PWD" != / &&
    test "$pwd_out" != / &&
    test "$PWD" != // && # two slashes may not be shortened to a single slash
    test "$pwd_out" != // &&

    # check for home directory
    test "$PWD" != "$HOME" &&
    test "$pwd_out" != "$HOME"
) }

#-------------------------------------------------------------------------------
# DYNAMIC INITIALIZATION
#-------------------------------------------------------------------------------
# All constants of this section can be read in other code. All global variables
# of this section can be accessed in other code.
#-------------------------------------------------------------------------------

# DESCRIPTION:
#   Initializes a runtime environment for GitPack. After calling this function,
#   GitPack's environment, logging and file structure will be prepared.
init_runtime() {
    init_global_vars &&
    init_paths &&
    log "$LOGTYPE_INIT" "$COMMAND" && # initialize logging
    init_traps &&
    init_database
}

# DESCRIPTION:
#   Initializes global variables. If there is a global variable, it must be
#   stated here even though its value is going to be overwritten.
init_global_vars() {
    # check if running as root and set up access level
    id_out="$(id -u)" && # not a global variable
    if [ "$id_out" -eq 0 ]; then
        access=global
    else
        access=local
    fi &&
    system="$(uname)" && # get the current system name

    state= && # the state of the processed project
    dep_prefix= && # prefix for processing dependencies
    dep_depth=0 # current dependency depth
}

# DESCRIPTION:
#   Initializes all GitPack-specific paths. They must start with '/' and must
#   not be changed later.
init_paths() {
    if [ "$access" = global ]; then
        CACHE_DIR=/var/cache/gitpack
        DB_DIR=/var/lib/gitpack
        LOG_PATH=/var/log/gitpack.log
    else
        CACHE_DIR="${HOME:?}"/.cache/gitpack
        DB_DIR="$HOME"/.local/share/gitpack
        LOG_PATH="$HOME"/.local/share/gitpack.log
    fi

    # derived paths
    CACHE_REPO_DIR="$CACHE_DIR"/repo # cache for Git repositories
    STATUS_PATH="$DB_DIR"/status # database of installed projects
}

# DESCRIPTION:
#   Initializes traps of all handled signals in GitPack.
init_traps() {
    trap 'log "$LOGTYPE_EXIT" "$?"' EXIT && # log GitPack exit status on exit
    trap term_action HUP INT QUIT TERM # handle termination signals
}

# DESCRIPTION:
#   This function is expected to handle all termination signals that can be sent
#   to GitPack. It logs the signal name and exits with its exit status.
term_action() {
    status="$?" # get exit status of the signal
    log "$LOGTYPE_SIGNAL" "SIG$(kill -l "$status")" # log signal name
    exit "$status" # exit GitPack (it also invokes the EXIT trap)
}

# DESCRIPTION:
#   Initializes GitPack's file structure including the check of its database
#   based on prepared global variables. It fails if it cannot create a file or
#   a directory or if GitPack does not have read or write permissions.
init_database() {
    # create GitPack status file if it does not exist
    if [ ! -e "$STATUS_PATH" ]; then
        dirname_out="$(dirname "$STATUS_PATH")" &&
        mkdir -p "$dirname_out"/ &&
        touch "$STATUS_PATH"
    fi &&

    # check access to GitPack status file
    if [ ! -r "$STATUS_PATH" ] || [ ! -w "$STATUS_PATH" ]; then
        echof "cannot access $STATUS_PATH file"
        return 1
    fi
}

#-------------------------------------------------------------------------------
# LOGGING
#-------------------------------------------------------------------------------

# DESCRIPTION:
#   Creates a new log item in the predefined log file with current date and time
#   based on a given type and details.
# PARAMETERS:
#   $1 - type
#   $2.. - details (optional)
log() {
    date_out="$(date '+%Y-%m-%d %H:%M:%S')" && # catch time immediately
    logtype="$1" && # use the given log type
    shift && # shift arguments to details

    details= && # start with no details
    for detail in "$@"; do # get all details
        if [ "$detail" ]; then # ignore empty ones
            details="$details $detail"
        fi
    done &&

    # store the log item
    echo "$date_out [$logtype]$details" >> "$LOG_PATH"
}

# DESCRIPTION:
#   Prints given echo arguments to standard error stream and logs the same into
#   the GitPack log file as a fail.
# PARAMETERS:
#   $@ - echo arguments
echof() {
    echo "$@" >&2 # print the fail
    log "$LOGTYPE_FAIL" "$@" # log the fail
}

#-------------------------------------------------------------------------------
# ACTION PROCESSING
#-------------------------------------------------------------------------------

# DESCRIPTION:
#   Performs several checks, prepares target Git repository and executes the
#   given action itself. Requires GitPack's runtime to be already initialized.
#   Also prints a report after the execution.
# PARAMETERS:
#   $1 - action
#   $2 - reference
process_action() {
    {   # log current action processing
        log "$LOGTYPE_ACTION" "$1" "$2" &&
        # process given reference - URL + version (optional)
        url="$(ref_to_url "$2")" &&
        version="$(ref_to_version "$2")" &&
        check_url "$url" &&

        # prepare Git repository
        clone_repo "$url" &&

        # execute the action itself
        execute_action "$1" "$url" "$version"
    } || {
        # all possible errors during action processing are caught here
        action_status="$?" # store the action exit status
        echo "${dep_prefix}<ERROR> $1 $2" >&2 # report GitPack information
        return "$action_status" # propagate the status further
    }
}

# DESCRIPTION:
#   Extracts and normalizes the URL from a given reference.
# PARAMETERS:
#   $1 - reference
ref_to_url() {
    url="${1%%=*}" # remove version if any
    url="${url#https://}" # remove https:// prefix
    url="${url%.git}" # remove .git suffix
    echo "$url" | tr '[:upper:]' '[:lower:]' # to lowercase
}

# DESCRIPTION:
#   Extracts a version from a given reference if there is any. Always succeeds.
# PARAMETERS:
#   $1 - reference
ref_to_version() {
    version="${1#*=}" # remove URL and keep version
    if [ "$version" != "$1" ]; then # check if there was a version
        echo "$version"
    fi
}

# DESCRIPTION:
#   Checks whether a given URL is supported.
# PARAMETERS:
#   $1 - URL
check_url() {
    log "$LOGTYPE_URL" "$1" || return
    url_regex='^[[:alnum:]_][[:alnum:]_\.-]*(/[[:alnum:]_][[:alnum:]_\.-]*){2}$'

    if ! echo "$1" | grep -q -E "$url_regex"; then
        echof 'unsupported URL delivered'
        return 1
    fi
}

#-------------------------------------------------------------------------------
# PREPARE REPOSITORY
#-------------------------------------------------------------------------------

# DESCRIPTION:
#   Refreshes a Git repository from given URL. In case an associated directory
#   does not exist, it is created and the repository is cloned. Otherwise, the
#   repository is refreshed by fetching and merging changes.
# PARAMETERS:
#   $1 - URL
clone_repo() { (
    repo_dir="$(url_to_path "$1")" && # get the repository directory path
    log "$LOGTYPE_CLONE" "$1" "$repo_dir"/ &&
    mkdir -p "$repo_dir"/ &&
    cd "$repo_dir"/ &&

    if [ ! "$(ls -A)" ]; then # if cached project directory is empty
        # clone Git repository master branch, it may ask a user for a password
        git clone -q --branch master https://"$1".git .
    else
        # checkout the master branch (also discard any changes)
        git checkout -qf master &&
        # fetch changes from master and merge them into local master branch
        git pull -q
    fi
) }

# DESCRIPTION:
#   Transforms a given URL of a Git repository to an actual path where the local
#   repository is stored.
# PARAMETERS:
#   $1 - URL
url_to_path() {
    echo "$CACHE_REPO_DIR"/"$1"
}

#-------------------------------------------------------------------------------
# CHOOSE ACTION
#-------------------------------------------------------------------------------

# DESCRIPTION:
#   Chooses which action will be executed and executes it with an initialized
#   Git repository. If no version is delivered, GitPack chooses the preferred
#   commit instead. Also prints a report after the execution.
# PARAMETERS:
#   $1 - action
#   $2 - URL
#   $3 - version (optional)
execute_action() {
    log "$LOGTYPE_EXECUTE" "$1" "$2" "$3" &&
    # get source (already installed) project information
    src_db_record="$(get_db_record "$2")" &&
    src_hash="${src_db_record#* }" && # extract commit hash
    # get target (installation candidate) project information
    tar_hash="$(get_repo_hash "$2" "$3")" &&

    # process dependencies first
    process_deps "$1" "$2" "$tar_hash" &&

    # choose action and execute it
    case "$1" in
        "$ACTION_INSTALL") execute_install "$2" "$src_hash" "$tar_hash" ;;
        "$ACTION_UNINSTALL") execute_uninstall "$2" "$src_hash" ;;
        "$ACTION_STATUS") execute_status "$2" "$src_hash" "$tar_hash" ;;
    esac &&

    print_report "$state" "$2" "$src_hash" "$tar_hash"
}

# DESCRIPTION:
#   Prints a preferred commit hash of a given project. It chooses latest tag's
#   commit if it exists, otherwise latest commit is chosen.
# PARAMETERS:
#   $1 - URL
#   $2 - version (optional)
get_repo_hash() { (
    repo_cd "$1" &&

    if [ "$2" ]; then
        git rev-parse "$2"'^{}' # transform delivered version to commit hash
    elif tag_name="$(git describe --tags --abbrev=0 master 2>/dev/null)"; then
        git rev-parse "$tag_name"'^{}' # transform latest tag to commit hash
    else
        git rev-parse master # get latest commit hash
    fi
) }

# DESCRIPTION:
#   Changes current working directory to a given repository and checkouts its
#   given commit. If the commit parameter is empty, no checkout is performed.
# PARAMETERS:
#   $1 - URL
#   $2 - commit (optional)
repo_cd() {
    cd "$(url_to_path "$1")"/ && # transform the given URL to path
    if [ "$2" ]; then
        git checkout -q "$2"
    fi
}

#-------------------------------------------------------------------------------
# PROCESS DEPENDENCIES
#-------------------------------------------------------------------------------

# DESCRIPTION:
#   Processes all dependencies of a given project considering the given action.
#   It also checks whether a defined dependency depth was not exceeded.
# PARAMETERS:
#   $1 - action
#   $2 - URL
#   $3 - commit
process_deps() {
    if [ "$1" = "$ACTION_UNINSTALL" ]; then
        return 0 # early return in the uninstall case
    fi

    deps="$(get_deps "$2" "$3")" && # get all dependencies
    if [ "$deps" ]; then # if there are any
        # run the given action recursively for each dependency reference
        echo "$deps" | while read -r dep; do # run them in separate subshells
            (   next_dep_depth && # register a new dependency depth level
                process_action "$1" "$dep"
            ) || return
        done
    fi
}

# DESCRIPTION:
#   Prints all dependencies of a given project's URL and commit if any.
# PARAMETERS:
#   $1 - URL
#   $2 - commit
get_deps() { (
    repo_cd "$1" "$2" &&
    # if there is a file describing dependencies
    if [ -r .gitpack/deps ]; then
        log "$LOGTYPE_DEPS" "$1" "$2" &&
        grepe '^[^#]' .gitpack/deps # remove empty and comment lines
    fi
) }

# DESCRIPTION:
#   This function is a grep wrapper. Succeeds even in the case of an empty grep
#   selection.
# PARAMETERS:
#   $@ - grep arguments
grepe() {
    grep "$@" # execute the grep itself
    grep_status="$?" # store its exit status

    # suppress the empty selection error indicator (exit status of 1)
    if [ "$grep_status" -eq 1 ]; then
        grep_status=0
    fi
    return "$grep_status" # return the modified exit status
}

# DESCRIPTION:
#   Prepares the environment for a new dependency depth level. It also checks
#   whether it is possible to continue processing dependencies.
next_dep_depth() {
    dep_prefix='+ ' # set up the prefix to make the GitPack report more clear
    dep_depth=$((dep_depth + 1)) # increment dependency depth

    # check whether the new dependency depth value is valid
    if [ "$dep_depth" -gt "$MAX_DEP_DEPTH" ]; then
        echof 'maximum dependency depth reached'
        return 1
    fi
}

#-------------------------------------------------------------------------------
# ACTION EXECUTION
#-------------------------------------------------------------------------------

# DESCRIPTION:
#   Decides whether install, update, or do nothing with a given project. If any
#   operation is done, it will use only given commits and also updates the
#   GitPack database.
# PARAMETERS:
#   $1 - URL
#   $2 - source commit (optional)
#   $3 - target commit
execute_install() {
    if [ ! "$2" ]; then
        state="$STATE_INSTALL" && # installation
        install "$1" "$3" && # install target commit
        insert_db_record "$1" "$3" # update GitPack database
    elif [ "$2" = "$3" ]; then
        state="$STATE_INSTALLED" # already installed
    else
        # check if installed version is older than the target
        if is_ancestor_commit "$1" "$2" "$3"; then
            state="$STATE_UPDATE" # update
        else
            state="$STATE_DOWNGRADE" # downgrade
        fi &&
        uninstall "$1" "$2" && # uninstall source commit
        delete_db_records "$1" && # update GitPack database
        install "$1" "$3" && # install target commit
        insert_db_record "$1" "$3" # update GitPack database
    fi
}

# DESCRIPTION:
#   Decides whether uninstall, or do nothing with a given project. If any
#   operation is done, it will use only given commit and also updates the
#   GitPack database.
# PARAMETERS:
#   $1 - URL
#   $2 - commit
execute_uninstall() {
    if [ "$2" ]; then # if installed
        state="$STATE_UNINSTALL" && # uninstallation
        uninstall "$1" "$2" && # uninstall given commit
        delete_db_records "$1" # update GitPack database
    else
        state="$STATE_UNINSTALLED" # already uninstalled
    fi
}

# DESCRIPTION:
#   Checks the given repository considering given source and target commits. It
#   always succeeds.
# PARAMETERS:
#   $1 - URL
#   $2 - source commit
#   $3 - target commit
execute_status() {
    if [ ! "$2" ]; then
        state="$STATE_NOTHING" # nothing installed from the URL
    elif [ "$2" = "$3" ]; then
        state="$STATE_OK" # the same as latest version
    else
        # check if installed version is older than the target
        if is_ancestor_commit "$1" "$2" "$3"; then
            state="$STATE_OLDER" # older than latest version
        else
            state="$STATE_NEWER" # newer than latest version
        fi
    fi
}

# DESCRIPTION:
#   Checks whether the first given commit is an ancestor of the second commit in
#   a given Git repository.
# PARAMETERS:
#   $1 - URL
#   $2 - first commit
#   $3 - second commit
is_ancestor_commit() { (
    repo_cd "$1" &&
    git merge-base --is-ancestor "$2" "$3"
) }

#-------------------------------------------------------------------------------
# DATABASE OPERATIONS
#-------------------------------------------------------------------------------

# DESCRIPTION:
#   Selects the first record matching the given URL from the GitPack database.
# PARAMETERS:
#   $1 - URL
get_db_record() {
    log "$LOGTYPE_GET" "$1" "$STATUS_PATH" &&
    grepe_out="$(grepe -F "$1" "$STATUS_PATH")" &&
    echo "$grepe_out" | head -n 1
}

# DESCRIPTION:
#   Inserts a given installation record into the GitPack database.
# PARAMETERS:
#   $1 - URL
#   $2 - commit hash
insert_db_record() {
    log "$LOGTYPE_INSERT" "$1" "$2" "$STATUS_PATH" &&
    echo "$1 $2" >> "$STATUS_PATH"
}

# DESCRIPTION:
#   Deletes all installation records with given URL from the GitPack database.
# PARAMETERS:
#   $1 - URL
delete_db_records() {
    log "$LOGTYPE_DELETE" "$1" "$STATUS_PATH" &&
    grepe_out="$(grepe -F -v "$1" "$STATUS_PATH")" &&
    echo "$grepe_out" > "$STATUS_PATH"
}

#-------------------------------------------------------------------------------
# INSTALLATION AND UNINSTALLATION
#-------------------------------------------------------------------------------

# DESCRIPTION:
#   Installs a project based on a given repository URL and commit.
# PARAMETERS:
#   $1 - URL
#   $2 - commit
install() { (
    repo_cd "$1" "$2" &&
    install_method="$(get_install_method)" && # choose the installation method
    install_dir="$(install_method_to_path "$install_method")" &&

    if [ -x "$install_dir"/precp ]; then # before files copy
        log "$LOGTYPE_PRECP" "$1" "$2" "$install_method" &&
        run_control_script "$install_dir"/precp
    fi &&

    # copy all files by defined routes
    log "$LOGTYPE_CP" "$1" "$2" "$install_method" &&
    for_each_route "$install_dir"/map copy_files &&

    if [ -x "$install_dir"/postcp ]; then # after files copy
        log "$LOGTYPE_POSTCP" "$1" "$2" "$install_method" &&
        run_control_script "$install_dir"/postcp
    fi
) }

# DESCRIPTION:
#   Uninstalls a project based on a given repository URL and commit.
# PARAMETERS:
#   $1 - URL
#   $2 - commit
uninstall() { (
    repo_cd "$1" "$2" &&
    install_method="$(get_install_method)" && # choose the uninstallation method
    install_dir="$(install_method_to_path "$install_method")" &&

    if [ -x "$install_dir"/prerm ]; then # before files removal
        log "$LOGTYPE_PRERM" "$1" "$2" "$install_method" &&
        run_control_script "$install_dir"/prerm
    fi &&

    # remove all files by defined routes
    log "$LOGTYPE_RM" "$1" "$2" "$install_method" &&
    for_each_route "$install_dir"/map remove_files &&

    if [ -x "$install_dir"/postrm ]; then # after files removal
        log "$LOGTYPE_POSTRM" "$1" "$2" "$install_method" &&
        run_control_script "$install_dir"/postrm
    fi
) }

# DESCRIPTION:
#   Prints the appropriate GitPack installation method based on the current
#   runtime and system information.
get_install_method() {
    if [ -d .gitpack/install/"${access}-$system"/ ]; then
        echo "${access}-$system" # system-specific directory
    else
        echo "$access" # system-independent directory
    fi
}

# DESCRIPTION:
#   Transforms a given installation method to an actual relative path where the
#   instructions are stored.
# PARAMETERS:
#   $1 - installation method
install_method_to_path() {
    echo .gitpack/install/"$1"
}

#-------------------------------------------------------------------------------
# CONTROL SCRIPT EXECUTION
#-------------------------------------------------------------------------------

# DESCRIPTION:
#   Runs a given control script of a GitPack project with a timeout. In case of
#   a timeout or a script fail, it prints an error report.
# PARAMETERS:
#   $1 - control script path
run_control_script() {
    timeout "$SCRIPT_TIMEOUT" "$1" && # run the script with a predefined timeout
    return # return early if the script returned successfully and not timed out

    timeout_status="$?" # store the failed exit status of the timeout
    # exit status of the SIGCHLD signal indicates a timeout
    if [ "$timeout_status" -eq "$SIGCHLD_EXIT_STATUS" ]; then
        echof "$(basename "$1") script timed out"
    else # otherwise, the script execution failed with the returned exit status
        echof "$(basename "$1") script execution failed with $timeout_status"
    fi
    return 1 # indicate error but do not propagate the exit status further
}

# DESCRIPTION:
#   Runs a given script with a given timeout. Returns a SIGCHLD exit status when
#   timed out. Otherwise, returns the exit status of the given script execution.
# PARAMETERS:
#   $1 - duration in seconds
#   $2 - script path
timeout() { (
    # in case of a termination signal, kill both processes and exit
    trap 'timeout_term_action "$sleep_pid" "$script_pid"' HUP INT QUIT TERM &&
    # once a child process terminates, both processes must be killed
    trap 'kill "$sleep_pid" "$script_pid" 2>/dev/null' CHLD || return

    ./"$2" & script_pid="$!" # run the given script and store its process ID
    sleep "$1" & sleep_pid="$!" # run the timer and store its process ID
    wait "$script_pid" # wait for the script to terminate (or get killed)
) }

# DESCRIPTION:
#   This function is expected to handle all termination signals that can be sent
#   to timeout during its execution. It kills both sleep and script processes.
# PARAMETERS:
#   $1 - sleep process ID
#   $2 - script process ID
timeout_term_action() {
    status="$?" # get exit status of the signal
    kill "$1" "$2" 2>/dev/null # kill both timeout processes
    exit "$status" # exit timeout
}

#-------------------------------------------------------------------------------
# COPY AND REMOVE FILES
#-------------------------------------------------------------------------------

# DESCRIPTION:
#   For each given map route, it calls a given function. It also prepares the
#   map by removing comments and empty lines before calling any function so that
#   it contains only required routes.
# PARAMETERS:
#   $1 - map path
#   $2 - function name
for_each_route() {
    if [ -r "$1" ]; then # check whether the map file exists
        grepe_out="$(grepe '^[^#]' "$1")" && # remove empty and comment lines
        if [ "$grepe_out" ]; then # if there are any routes in the path file
            # call a given function for each route
            echo "$grepe_out" | while read -r route; do
                eval "$2" "$route" || return
            done
        fi
    else # if the map file does not exist, fails
        echof 'missing map file'
        return 1
    fi
}

# DESCRIPTION:
#   Copies files recursively based on given source and target paths. It also
#   creates the target directory if it does not exist before copying.
# PARAMAETERS:
#   $1 - source path
#   $2 - target directory
copy_files() {
    : "${1:?}" "${2:?}" && # parameters must be set up
    mkdir -p -- "$2"/ && # create target directory
    cp -R -- "$1" "$2"/ # copy the files recursively
}

# DESCRIPTION:
#   Removes files based on given source and target paths.
# PARAMAETERS:
#   $1 - source path
#   $2 - target directory
remove_files() {
    : "${1:?}" "${2:?}" && # parameters must be set up
    basename_out="$(basename -- "$1")" && # get the last part of the source path
    if [ -d "$1"/ ]; then
        # scan source path to obtain files mask
        files="$(cd -- "$1"/ && find . ! -type d)" &&
        dirs="$(cd -- "$1"/ && find . ! -path . -type d)" &&

        (   # remove files and then directories by the files mask
            cd -- "$2"/ &&
            for file in $files; do
                rm -f -- "${basename_out:?}"/"${file:?}" || return
            done &&
            for dir in $dirs; do
                rmdir -p -- "${basename_out:?}"/"${dir:?}"/ 2>/dev/null; true
            done
        )
    else # remove the file as a regular file
        rm -f -- "${2:?}"/"${basename_out:?}"
    fi
}

#-------------------------------------------------------------------------------
# STATE REPORT
#-------------------------------------------------------------------------------

# DESCRIPTION:
#   Prints a report of a given Git project and all associated parameters.
# PARAMETERS:
#   $1 - state
#   $2 - URL
#   $3 - source commit
#   $4 - target commit
print_report() {
    # prepare given arguments
    prefix="${dep_prefix}[$1] $2" &&
    src_version="$(beautify_hash "$2" "$3")" &&
    tar_version="$(beautify_hash "$2" "$4")" &&

    case "$1" in
        "$STATE_INSTALL") echo "$prefix $tar_version" ;;
        "$STATE_UPDATE") echo "$prefix $tar_version <- $src_version" ;;
        "$STATE_DOWNGRADE") echo "$prefix $tar_version <- $src_version" ;;
        "$STATE_INSTALLED") echo "$prefix $src_version" ;;
        "$STATE_UNINSTALL") echo "$prefix $src_version" ;;
        "$STATE_UNINSTALLED") echo "$prefix" ;;
        "$STATE_NOTHING") echo "$prefix -> $tar_version" ;;
        "$STATE_OLDER") echo "$prefix $src_version -> $tar_version" ;;
        "$STATE_NEWER") echo "$prefix $src_version -> $tar_version" ;;
        "$STATE_OK") echo "$prefix $src_version" ;;
    esac
}

# DESCRIPTION:
#   Beautifies the given commit hash prepared for a use in a report. If there is
#   a tag associated with a given hash, uses this tag. Otherwise, it makes the
#   given hash shorter. Always succeeds.
# PARAMETERS:
#   $1 - URL
#   $2 - commit
beautify_hash() { (
    # check if given hash is associated with any tag
    if repo_cd "$1" 2>/dev/null &&
       tag_name="$(git describe --tags --exact-match "$2" 2>/dev/null)"; then
        echo "$tag_name"
    else # if no tag found, return short hash
        echo "$2" | cut -c 1-7
    fi
) }

#-------------------------------------------------------------------------------
# ENTRY POINT CALLING
#-------------------------------------------------------------------------------

main "$@" || exit
