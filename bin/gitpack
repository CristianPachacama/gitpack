#!/bin/sh

#-------------------------------------------------------------------------------
# Copyright 2019 Dominik Salvet
# SPDX-License-Identifier: MIT
# https://github.com/dominiksalvet/gitpack
#-------------------------------------------------------------------------------
# DESCRIPTION:
#   This is the main file of GitPack - Git-based package manager.
# PARAMETERS:
#   All given arguments are processed as GitPack's help describes.
#-------------------------------------------------------------------------------


#-------------------------------------------------------------------------------
# ENTRY POINT
#-------------------------------------------------------------------------------

# DESCRIPTION:
#   This is the GitPack entry point and it is expected to be executed first, yet
#   its calling should be at the end of this script.
# PARAMETERS:
#   $@ - GitPack arguments
main() {
    check_deps &&
    init_constants &&
    init_strings &&
    process_args "$@"
}

#-------------------------------------------------------------------------------
# SOFTWARE DEPENDENCIES
#-------------------------------------------------------------------------------

# DESCRIPTION:
#   Checks whether all software dependencies are satisfied.
check_deps() {
    # a list of required software
    sw_list='command echo [ cd test pwd rm id mkdir touch dirname grep git ls '\
'uname read cp head cut'

    # check if any piece of software is missing
    for sw in $sw_list; do
        if ! command -v "$sw" > /dev/null; then
            print_error "missing $sw software"
            return 1
        fi
    done
}

# DESCRIPTION:
#   Prints a given error text with a given hint text if present.
# PARAMETERS:
#   $1 - error text
#   $2 - hint text (optional)
print_error() {
    echo "$0: $1" >&2
    if [ "$2" ]; then
        echo "$2" >&2
    fi
}

#-------------------------------------------------------------------------------
# STATIC INITIALIZATION
#-------------------------------------------------------------------------------
# All constants of this section can be read in other code.
#-------------------------------------------------------------------------------

# DESCRIPTION:
#   Initializes static constants.
init_constants() {
    # the current version of GitPack
    VERSION=0.1.0

    # GitPack actions
    ACTION_INSTALL=install
    ACTION_UNINSTALL=uninstall
    ACTION_STATUS=status

    # project states of install action
    STATE_INSTALL=install # just installed
    STATE_UPDATE=update # just updated
    STATE_DOWNGRADE=downgrade # just downgraded
    STATE_INSTALLED=installed # already installed
    # project states of uninstall action
    STATE_UNINSTALL=uninstall # just uninstalled
    STATE_UNINSTALLED=uninstalled # already uninstalled
    # project states of status action
    STATE_NOTHING=nothing # project is not installed
    STATE_OLD=old # project is outdated
    STATE_LATEST=latest # project is fully updated
    STATE_DEV=dev # project is in a developer version
}

# DESCRIPTION:
#   Initializes strings usually used to display reports to the user. Constants
#   must be already initialized.
init_strings() {
    HELP_MESSAGE="USAGE:
  $0 ACTION URL[=VERSION]...
  $0 COMMAND

ACTION:
  $ACTION_INSTALL    install/update Git projects
  $ACTION_UNINSTALL  uninstall Git projects
  $ACTION_STATUS     show status of Git projects

COMMAND:
  clean  remove cache
  help   show this help
  about  show information"

    ABOUT_MESSAGE="GitPack $VERSION
Git-based package manager.

Copy"'right 2019 Dominik Salvet
SPDX License Identifier: MIT
https://github.com/dominiksalvet/gitpack'

    HINT_MESSAGE="Try '$0 help' for getting help."
}

#-------------------------------------------------------------------------------
# ARGUMENT PARSING
#-------------------------------------------------------------------------------

# DESCRIPTION:
#   Processes given GitPack arguments and performs all associated operations.
# PARAMETERS:
#   $@ - GitPack arguments
process_args() {
    # process first argument
    case "$1" in
        "$ACTION_INSTALL" | "$ACTION_UNINSTALL" | "$ACTION_STATUS")
            action="$1" # use the given action
            shift # shift arguments to references
            if [ "$#" -eq 0 ]; then # check if there is any reference argument
                print_error 'no URL provided' "$HINT_MESSAGE"
                return 1
            fi
            ;;
        clean) init_runtime && safe_rm_rf_dir "$CACHE_REPO_DIR"; return ;;
        help) echo "$HELP_MESSAGE"; return ;;
        about) echo "$ABOUT_MESSAGE"; return ;;
        '') print_error 'no argument provided' "$HINT_MESSAGE"; return 1 ;;
        *) print_error "unrecognized argument $1" "$HINT_MESSAGE"; return 1 ;;
    esac

    init_runtime &&
    for ref in "$@"; do # process each reference individually with common action
        process_action "$action" "$ref" || return
    done
}

# DESCRIPTION:
#   Removes a given directory with its content performing a check for the root
#   directory that is prevented to be removed and fails in that case. This
#   function uses only the first parameter, others are ignored!
# PARAMETERS:
#   $1 - directory path
safe_rm_rf_dir() {
    if [ -d "${1:?}"/ ]; then # check if the directory exists
        ( # remove only if the given directory path is not the root directory
            cd -- "${1:?}"/ 2>/dev/null &&
            test "$PWD" != / &&
            pwd_out="$(pwd -P)" &&
            test "$pwd_out" != /
        ) &&
        rm -rf -- "${1:?}"/
    fi
}

#-------------------------------------------------------------------------------
# DYNAMIC INITIALIZATION
#-------------------------------------------------------------------------------
# All variables and constants of this section can be accessed in other code.
#-------------------------------------------------------------------------------

# DESCRIPTION:
#   Prepares a runtime environment for GitPack. After calling this function,
#   GitPack's essential file structure will be prepared and appropriate
#   configuration will be applied.
init_runtime() {
    init_global_vars &&
    init_paths &&
    init_database
}

# DESCRIPTION:
#   Initializes global variables. If there is a global variable, it must be
#   stated here even though its value is going to be overwritten.
init_global_vars() {
    # check if running as root and set up access level
    id_out="$(id -u)" &&
    if [ "$id_out" -eq 0 ]; then
        access=global
    else
        access=local
    fi &&

    # get the current system name
    system="$(uname)"
}

# DESCRIPTION:
#   Initializes all GitPack-specific paths. They must start with '/'.
init_paths() {
    if [ "$access" = global ]; then
        CACHE_DIR=/var/cache/gitpack
        DB_DIR=/var/lib/gitpack
    else
        CACHE_DIR="$HOME"/.cache/gitpack
        DB_DIR="$HOME"/.local/share/gitpack
    fi

    # derived paths
    CACHE_REPO_DIR="$CACHE_DIR"/repo # cache for Git repositories
    STATUS_PATH="$DB_DIR"/status # database of installed projects
}

# DESCRIPTION:
#   Initializes GitPack's file structure including the check of its database
#   based on prepared global variables. It fails if it cannot create a file or
#   a directory or if GitPack does not have read or write permissions.
init_database() {
    # create GitPack status file if it does not exist
    if [ ! -e "$STATUS_PATH" ]; then
        dirname_out="$(dirname "$STATUS_PATH")" &&
        mkdir -p "$dirname_out"/ &&
        touch "$STATUS_PATH"
    fi &&

    # check access to GitPack status file
    if [ ! -r "$STATUS_PATH" ] || [ ! -w "$STATUS_PATH" ]; then
        print_error "cannot access $STATUS_PATH file"
        return 2
    fi
}

#-------------------------------------------------------------------------------
# ACTION PROCESSING
#-------------------------------------------------------------------------------

# DESCRIPTION:
#   Performs several checks, prepares target Git repository and executes the
#   given action itself. Requires GitPack's runtime to be already initialized.
#   Also prints a report after the execution.
# PARAMETERS:
#   $1 - action
#   $2 - reference
process_action() {
    { # process given reference - URL + version (optional)
    url="$(ref_to_url "$2")" &&
    version="$(ref_to_version "$2")" &&
    check_url "$url" &&

    # prepare Git repository
    touch_repo "$url" &&

    # execute the action itself
    execute_action "$1" "$url" "$version"
    } || { # all possible errors during action processing are caught here
        return_val="$?" # store return value
        echo "<ERROR> $1 $2" >&2 # print some relevant GitPack information
        return "$return_val" # propagate the return value further
    }
}

# DESCRIPTION:
#   Extracts an URL from a given reference.
# PARAMETERS:
#   $1 - reference
ref_to_url() {
    url="${1%%=*}" && # remove version if any
    url="${url#https://}" && # remove https:// prefix
    echo "${url%.git}" # remove .git suffix
}

# DESCRIPTION:
#   Extracts a version from a given reference if there is any. Always succeeds.
# PARAMETERS:
#   $1 - reference
ref_to_version() {
    version="${1#*=}" && # remove URL and keep version
    if [ "$version" != "$1" ]; then # check if there was a version
        echo "$version"
    fi
}

# DESCRIPTION:
#   Checks whether a given URL is supported.
# PARAMETERS:
#   $1 - URL
check_url() {
    url_regex='^[[:alnum:]_][[:alnum:]_\.-]*(/[[:alnum:]_][[:alnum:]_\.-]*){2}$'

    if ! echo "$1" | grep -q -E "$url_regex"; then
        echo "$0: unsupported URL delivered" >&2
        return 1
    fi
}

#-------------------------------------------------------------------------------
# PREPARE REPOSITORY
#-------------------------------------------------------------------------------

# DESCRIPTION:
#   Refreshes a Git repository from given URL. In case an associated directory
#   does not exist, it is created and the repository is cloned. Otherwise, the
#   repository is refreshed by fetching and merging changes.
# PARAMETERS:
#   $1 - URL
touch_repo() { (
    mkdir -p "$CACHE_REPO_DIR"/"$1"/ &&
    cd "$CACHE_REPO_DIR"/"$1"/ &&

    if [ ! "$(ls -A)" ]; then # if cached project directory is empty
        # clone Git repository master branch, it may ask a user for a password
        git clone -q --branch master https://"$1".git .
    else
        # discard any changes made to repository (just for case)
        git clean -q -d -f &&
        git reset -q --hard &&

        # checkout the master branch
        git checkout -q master &&
        # fetch changes from master and merge them into local master branch
        git pull -q
    fi
) }

#-------------------------------------------------------------------------------
# CHOOSE ACTION
#-------------------------------------------------------------------------------

# DESCRIPTION:
#   Chooses which action will be executed and executes it with an initialized
#   Git repository. If no target version is delivered, GitPack chooses
#   a preferred commit instead. Also prints a report after the execution.
# PARAMETERS:
#   $1 - action
#   $2 - URL
#   $3 - target version (optional)
execute_action() {
    # get source (already installed) project information
    src_db_record="$(get_db_record "$2")" &&
    src_url="${src_db_record%% *}" && # extract url
    src_hash="${src_db_record#* }" && # extract commit hash
    # get target (installation candidate) project information
    if [ "$3" ]; then
        tar_hash="$(git rev-parse "$3"'^{}')" # transform version to commit hash
    else
        tar_hash="$(get_repo_hash "$2")" # get preferred commit hash
    fi &&

    # print report
    print_report "$state" "$2" "$src_hash" "$tar_hash"
}

# DESCRIPTION:
#   Selects the first record matching the given URL from the GitPack database.
# PARAMETERS:
#   $1 - URL
get_db_record() {
    grep -F "$1" "$STATUS_PATH" | head -n 1
}

# DESCRIPTION:
#   Returns a preferred commit hash of a given project. It chooses latest tag's
#   commit if it exists, otherwise latest commit is chosen.
# PARAMETERS:
#   $1 - URL
get_repo_hash() { (
    cd_repo "$1" &&
    # latest tag (of any type)
    if tag_name="$(git describe --tags --abbrev=0 master 2>/dev/null)"; then
        git rev-parse "$tag_name"'^{}' # transform latest version to commit hash
    else # latest commit
        git rev-parse master
    fi
) }

# DESCRIPTION:
#   Changes current working directory to a given repository and checkouts its
#   given commit. If the commit parameter is empty, no checkout is performed.
# PARAMETERS:
#   $1 - URL
#   $2 - commit (optional)
cd_repo() {
    cd "$CACHE_REPO_DIR"/"$1"/ &&
    if [ "$2" ]; then
        git checkout -q "$2"
    fi
}





#-------------------------------------------------------------------------------
# INSTALLATION AND UNINSTALLATION
#-------------------------------------------------------------------------------

# DESCRIPTION:
#   Installs a project based on a given repository URL and commit hash.
# $1 - URL
# $2 - commit hash
install() { (
    cd_repo "$1" "$2" &&
    # choose the most appropriate installation method
    if [ -d .gitpack/install/"${access}-$system"/ ]; then
        cd .gitpack/install/"${access}-$system"/ # specific for current system
    else
        cd .gitpack/install/"$access"/ # common global or local for all systems
    fi &&
    if [ -x preinst ]; then # before files copy
        ./preinst
    fi &&
    while read -r link; do # copy all files by defined links
        eval cp -R -- $link
    done < links &&
    if [ -x postinst ]; then # after files copy
        ./postinst
    fi
) }





#-------------------------------------------------------------------------------
# STATE REPORT
#-------------------------------------------------------------------------------

# DESCRIPTION:
#   Prints a report of a given Git project and all associated parameters.
# PARAMETERS:
#   $1 - state
#   $2 - URL
#   $3 - source commit hash
#   $4 - target commit hash
print_report() {
    # prepare given arguments
    prefix="[$1] $2" &&
    src_version="$(beautify_hash "$2" "$3")" &&
    tar_version="$(beautify_hash "$2" "$4")" &&

    case "$1" in
        "$STATE_INSTALL") echo "$prefix $tar_version" ;;
        "$STATE_UPDATE") echo "$prefix $tar_version <- $src_version" ;;
        "$STATE_DOWNGRADE") echo "$prefix $tar_version <- $src_version" ;;
        "$STATE_INSTALLED") echo "$prefix $src_version" ;;
        "$STATE_UNINSTALL") echo "$prefix $src_version" ;;
        "$STATE_UNINSTALLED") echo "$prefix" ;;
        "$STATE_NOTHING") echo "$prefix -> $tar_version" ;;
        "$STATE_OLD") echo "$prefix $src_version -> $tar_version" ;;
        "$STATE_LATEST") echo "$prefix $src_version" ;;
        "$STATE_DEV") echo "$prefix $src_version -> $tar_version" ;;
    esac
}

# DESCRIPTION:
#   Beautifies the given commit hash prepared for a use in a report. If there is
#   a tag associated with a given hash, uses this tag. Otherwise, it makes the
#   given hash shorter. Always succeeds.
# PARAMETERS:
#   $1 - URL
#   $2 - commit hash
beautify_hash() { (
    # check if given hash is associated with any tag
    if cd_repo "$1" 2>/dev/null &&
       tag_name="$(git describe --tags --exact-match "$2" 2>/dev/null)"; then
        echo "$tag_name"
    else # if no tag found, return short hash
        echo "$2" | cut -c 1-7
    fi
) }

#-------------------------------------------------------------------------------
# ENTRY POINT CALLING
#-------------------------------------------------------------------------------

main "$@" || exit
