#!/bin/sh

#-------------------------------------------------------------------------------
# Copyright 2019 Dominik Salvet
# SPDX-License-Identifier: MIT
# https://github.com/dominiksalvet/gitpack
#-------------------------------------------------------------------------------
# DESCRIPTION:
#   This is the main file of GitPack - Git-based package manager.
# PARAMETERS:
#   All given arguments are processed as GitPack's help describes.
#-------------------------------------------------------------------------------


#-------------------------------------------------------------------------------
# ENTRY POINT
#-------------------------------------------------------------------------------

# DESCRIPTION:
#   This is the GitPack entry point and it is expected to be executed first, yet
#   its calling should be at the end of this script.
# PARAMETERS:
#   $@ - GitPack arguments
main() {
    check_deps &&
    init_constants &&
    init_strings &&
    process_args "$@"
}

#-------------------------------------------------------------------------------
# SOFTWARE DEPENDENCIES
#-------------------------------------------------------------------------------

# DESCRIPTION:
#   Checks whether all software dependencies are satisfied.
check_deps() {
    # a list of required software
    sw_list='command echo [ cd test pwd rm id mkdir touch dirname grep git ls uname read cp'

    # check if any piece of software is missing
    for sw in $sw_list; do
        if ! command -v -- "$sw" > /dev/null; then
            print_error "missing $sw software"
            return 1
        fi
    done
}

# DESCRIPTION:
#   Prints a given error text with a given hint text if present.
# PARAMETERS:
#   $1 - error text
#   $2 - hint text (optional)
print_error() {
    echo "$0: $1" >&2
    if [ "$2" ]; then
        echo "$2" >&2
    fi
}

#-------------------------------------------------------------------------------
# STATIC INITIALIZATION
#-------------------------------------------------------------------------------
# All constants of this section can be read in other code.
#-------------------------------------------------------------------------------

# DESCRIPTION:
#   Initializes static constants.
init_constants() {
    # the current version of GitPack
    VERSION=0.1.0

    # GitPack actions
    ACTION_INSTALL=install
    ACTION_UNINSTALL=uninstall
    ACTION_STATUS=status
}

# DESCRIPTION:
#   Initializes strings usually used to display reports to the user. Constants
#   must be already initialized.
init_strings() {
    HELP_MESSAGE="USAGE:
  $0 ACTION URL[=VERSION]...
  $0 COMMAND

ACTION:
  $ACTION_INSTALL    install/update Git projects
  $ACTION_UNINSTALL  uninstall Git projects
  $ACTION_STATUS     show status of Git projects

COMMAND:
  clean  remove cache
  help   show this help
  about  show information"

    ABOUT_MESSAGE="GitPack $VERSION
Git-based package manager.

Copy"'right 2019 Dominik Salvet
SPDX License Identifier: MIT
https://github.com/dominiksalvet/gitpack'

    HINT_MESSAGE="Try '$0 help' for getting help."
}

#-------------------------------------------------------------------------------
# ARGUMENT PARSING
#-------------------------------------------------------------------------------

# DESCRIPTION:
#   Processes given GitPack arguments and performs all associated operations.
# PARAMETERS:
#   $@ - GitPack arguments
process_args() {
    # process first argument
    case "$1" in
        "$ACTION_INSTALL" | "$ACTION_UNINSTALL" | "$ACTION_STATUS")
            action="$1" # use the given action
            shift # shift arguments to URLs
            if [ "$#" -eq 0 ]; then # check if there is any URL argument
                print_error 'no URL provided' "$HINT_MESSAGE"
                return 1
            fi
            ;;
        clean) init_runtime && safe_rm_rf_dir "$CACHE_REPO_DIR"; return ;;
        help) echo "$HELP_MESSAGE"; return ;;
        about) echo "$ABOUT_MESSAGE"; return ;;
        '') print_error 'no argument provided' "$HINT_MESSAGE"; return 1 ;;
        *) print_error "unrecognized argument $1" "$HINT_MESSAGE"; return 1 ;;
    esac

    init_runtime &&
    for url in "$@"; do # process each URL individually with common action
        process_action "$action" "$url" || return
    done
}

# DESCRIPTION:
#   Removes a given directory with its content performing a check for the root
#   directory that is prevented to be removed and fails in that case. This
#   function uses only the first parameter, others are ignored!
# PARAMETERS:
#   $1 - directory path
safe_rm_rf_dir() {
    if [ -d "${1:?}"/ ]; then # check if the directory exists
        ( # remove only if the given directory path is not the root directory
            cd -- "${1:?}"/ 2>/dev/null &&
            test "$PWD" != / &&
            pwd_out="$(pwd -P)" &&
            test "$pwd_out" != /
        ) &&
        rm -rf -- "${1:?}"/
    fi
}

#-------------------------------------------------------------------------------
# DYNAMIC INITIALIZATION
#-------------------------------------------------------------------------------
# All variables and constants of this section can be accessed in other code.
#-------------------------------------------------------------------------------

# DESCRIPTION:
#   Prepares a runtime environment for GitPack. After calling this function,
#   GitPack's essential file structure will be prepared and appropriate
#   configuration will be applied.
init_runtime() {
    init_global_vars &&
    init_paths &&
    init_database
}

# DESCRIPTION:
#   Initializes global variables. If there is a global variable, it must be
#   stated here even though its value is going to be overwritten.
init_global_vars() {
    # check if running as root and set up access level
    id_out="$(id -u)" &&
    if [ "$id_out" -eq 0 ]; then
        access=global
    else
        access=local
    fi &&

    # get the current system name
    system="$(uname)"
}

# DESCRIPTION:
#   Initializes all GitPack-specific paths. They must start with '/'.
init_paths() {
    if [ "$access" = global ]; then
        CACHE_DIR=/var/cache/gitpack
        DB_DIR=/var/lib/gitpack
    else
        CACHE_DIR="$HOME"/.cache/gitpack
        DB_DIR="$HOME"/.local/share/gitpack
    fi

    # derived paths
    CACHE_REPO_DIR="$CACHE_DIR"/repo # cache for Git repositories
    STATUS_PATH="$DB_DIR"/status # database of installed projects
}

# DESCRIPTION:
#   Initializes GitPack's file structure including the check of its database
#   based on prepared global variables. It fails if it cannot create a file or
#   a directory or if GitPack does not have read or write permissions.
init_database() {
    # create GitPack status file if it does not exist
    if [ ! -e "$STATUS_PATH" ]; then
        dirname_out="$(dirname "$STATUS_PATH")" &&
        mkdir -p "$dirname_out"/ &&
        touch "$STATUS_PATH"
    fi &&

    # check access to GitPack status file
    if [ ! -r "$STATUS_PATH" ] || [ ! -w "$STATUS_PATH" ]; then
        print_error "cannot access $STATUS_PATH file"
        return 2
    fi
}

#-------------------------------------------------------------------------------
# ACTION PROCESSING
#-------------------------------------------------------------------------------

# DESCRIPTION:
#   Performs several checks, prepares target Git repository and executes the
#   given action itself. Requires GitPack's runtime to be already initialized.
#   Also prints a report after the execution.
# PARAMETERS:
#   $1 - action
#   $2 - any URL
process_action() {
    { # process given URL, which may include version
    url="$(url_extract_short_url "$2")" &&
    version="$(url_extract_version "$2")" &&
    check_short_url "$url" &&

    # prepare Git repository
    touch_repo "$url" &&

    # execute the action itself
    execute_action "$1" "$url" "$version"
    } || { # all possible errors during action processing are caught here
        return_val="$?" # store return value
        echo "<ERROR> $1 $2" >&2 # print some relevant GitPack information
        return "$return_val" # propagate the return value further
    }
}

# DESCRIPTION:
#   Extracts a short URL from a given URL.
# PARAMETERS:
#   $1 - any URL
url_extract_short_url() {
    url="${1%%=*}" && # remove version if any
    url="${url#https://}" && # remove https:// prefix
    echo "${url%.git}" # remove .git suffix
}

# DESCRIPTION:
#   Extracts a version from a given URL.
# PARAMETERS:
#   $1 - any URL
url_extract_version() {
    version="${1#*=}" && # remove URL and keep version
    if [ "$version" != "$1" ]; then # check if there was a version
        echo "$version"
    fi
}

# DESCRIPTION:
#   Checks whether given short URL is supported.
# PARAMETERS:
#   $1 - URL
check_short_url() {
    url_regex='^[[:alnum:]_][[:alnum:]_\.-]*(/[[:alnum:]_][[:alnum:]_\.-]*){2}$'

    if ! echo "$1" | grep -q -E "$url_regex"; then
        echo "$0: unsupported URL delivered" >&2
        return 1
    fi
}

#-------------------------------------------------------------------------------
# PREPARE REPOSITORY
#-------------------------------------------------------------------------------

# DESCRIPTION:
#   Refreshes a Git repository from given URL. In case an associated directory
#   does not exist, it is created and the repository is cloned. Otherwise, the
#   repository is refreshed by fetching and merging changes.
# PARAMETERS:
#   $1 - URL
touch_repo() { (
    mkdir -p "$CACHE_REPO_DIR"/"$1"/ &&
    cd "$CACHE_REPO_DIR"/"$1"/ &&

    if [ ! "$(ls -A)" ]; then # if cached project directory is empty
        # clone Git repository master branch, it may ask a user for a password
        git clone -q --branch master https://"$1".git .
    else
        # discard any changes made to repository (just for case)
        git clean -q -d -f &&
        git reset -q --hard &&

        # checkout the master branch
        git checkout -q master &&
        # fetch changes from master and merge them into local master branch
        git pull -q
    fi
) }

#-------------------------------------------------------------------------------
# CHOOSE ACTION
#-------------------------------------------------------------------------------



















# DESCRIPTION:
#   Installs a project based on a given repository URL and commit hash.
# $1 - URL
# $2 - commit hash
install() { (
    cd_repo "$1" "$2" &&
    # choose the most appropriate installation method
    if [ -d .gitpack/methods/"${access}-$system"/ ]; then
        cd .gitpack/methods/"${access}-$system"/ # specific for current system
    else
        cd .gitpack/methods/"$access"/ # common global or local for all systems
    fi &&
    if [ -x preinst ]; then # before files copy
        ./preinst
    fi &&
    while read -r link; do # copy all files by defined links
        # shellcheck disable=SC2086
        eval cp -R -- $link
    done < links &&
    if [ -x postinst ]; then # after files copy
        ./postinst
    fi
) }


#-------------------------------------------------------------------------------
# ENTRY POINT CALLING
#-------------------------------------------------------------------------------

main "$@" || exit
